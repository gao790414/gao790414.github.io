<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 粒子爱心 - 允允 (完整版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; }
        
        /* UI 容器 */
        #ui-container { position: absolute; top: 20px; right: 20px; z-index: 10; }

        /* 底部提示 */
        .instruction {
            position: absolute; bottom: 80px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.8); pointer-events: none;
            font-size: 15px; letter-spacing: 2px; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0,0,0,0.8); z-index: 5;
            font-weight: bold;
        }
        .sub-instruction {
            display: block; font-size: 12px; color: rgba(255,255,255,0.5); margin-top: 5px; font-weight: normal;
        }

        /* 全屏按钮 */
        #fullscreen-btn {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; padding: 10px 15px; border-radius: 8px; cursor: pointer;
            backdrop-filter: blur(5px); transition: all 0.3s; z-index: 10; font-size: 12px;
        }
        #fullscreen-btn:hover { background: rgba(255, 255, 255, 0.3); }

        /* 摄像头预览 */
        #webcam-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 10; background: #000; display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #webcam-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #webcam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        #loading-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 12px; pointer-events: none; animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% {opacity:0.5;} 50% {opacity:1;} 100% {opacity:0.5;} }
    </style>
</head>
<body>

    <div id="ui-container"></div>
    <div class="instruction">
        单手操控模式
        <span class="sub-instruction">手掌移动旋转 · 拇指食指开合缩放 · 右上角调整粒子</span>
    </div>
    <div id="loading-text">正在启动视觉引擎...</div>
    <button id="fullscreen-btn">⛶ 全屏模式</button>

    <div id="webcam-container">
        <video id="webcam-video" autoplay playsinline muted></video>
        <canvas id="webcam-canvas"></canvas>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        // --- 配置参数 ---
        const config = {
            particleColor: '#ff69b4', // 初始颜色
            particleSize: 4.0,        // 初始大小
            dispersion: 0.0,
            handControl: true 
        };

        // --- 场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 粒子数据生成 ---
        function getTextCoordinates(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 500;
            canvas.width = size; canvas.height = size;
            ctx.font = 'bold 200px "Microsoft YaHei", sans-serif';
            ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, size / 2, size / 2);
            const data = ctx.getImageData(0, 0, size, size).data;
            const points = [];
            for (let y = 0; y < size; y += 4) {
                for (let x = 0; x < size; x += 4) {
                    if (data[(y * size + x) * 4 + 3] > 128) {
                        points.push({ x: (x - size/2)*0.15, y: -(y - size/2)*0.15, z: 0 });
                    }
                }
            }
            return points;
        }

        function getHeartCoordinates(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                points.push({ x: x * 0.5, y: y * 0.5, z: (Math.random() - 0.5) * 2 });
            }
            return points;
        }

        const allPoints = [...getTextCoordinates("允允"), ...getHeartCoordinates(1500)];
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(allPoints.length * 3);
        const randoms = new Float32Array(allPoints.length * 3);

        allPoints.forEach((p, i) => {
            positions[i*3] = p.x; positions[i*3+1] = p.y; positions[i*3+2] = p.z;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 2 - 1);
            const r = 20 + Math.random() * 20;
            randoms[i*3] = r * Math.sin(phi) * Math.cos(theta);
            randoms[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            randoms[i*3+2] = r * Math.cos(phi);
        });

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

        // --- Shader 材质 ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(config.particleColor) },
                uDispersion: { value: 0 },
                uSize: { value: config.particleSize * renderer.getPixelRatio() } // 初始化大小
            },
            vertexShader: `
                uniform float uTime;
                uniform float uDispersion;
                uniform float uSize;
                attribute vec3 aRandom;
                varying float vAlpha;
                void main() {
                    vec3 stablePos = position + vec3(0.0, sin(uTime * 2.0 + position.x) * 0.2, 0.0);
                    vec3 finalPos = mix(stablePos, stablePos + aRandom, uDispersion);
                    
                    // 粒子大小计算：基础大小 * (扩散膨胀) * (透视缩放)
                    gl_PointSize = uSize * (1.0 + uDispersion * 0.5);
                    gl_PointSize *= (20.0 / - (modelViewMatrix * vec4(finalPos, 1.0)).z);
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
                    vAlpha = 1.0 - uDispersion * 0.8;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vAlpha;
                void main() {
                    vec2 uv = gl_PointCoord.xy - 0.5;
                    float r = length(uv);
                    if (r > 0.5) discard;
                    float glow = pow(1.0 - (r * 2.0), 1.5);
                    gl_FragColor = vec4(uColor, vAlpha * glow);
                }
            `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 交互变量 ---
        let targetRotationY = 0;
        let targetDispersion = 0;
        let targetScale = 1.0;
        
        let isDragging = false, prevMouse = {x:0, y:0};
        const onMove = (x, y) => {
            if (!isDragging) return;
            targetRotationY += (x - prevMouse.x) * 0.005;
            targetDispersion += (y - prevMouse.y) * 0.005;
            targetDispersion = Math.max(0, Math.min(1, targetDispersion));
            config.dispersion = targetDispersion;
            prevMouse = { x, y };
        };
        window.addEventListener('mousedown', e => { isDragging=true; prevMouse={x:e.clientX, y:e.clientY}; });
        window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => isDragging=false);
        window.addEventListener('touchstart', e => { isDragging=true; prevMouse={x:e.touches[0].clientX, y:e.touches[0].clientY}; }, {passive:false});
        window.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        window.addEventListener('touchend', () => isDragging=false);

        // --- MediaPipe 单手逻辑 ---
        let handLandmarker;
        const video = document.getElementById('webcam-video');
        const canvasElement = document.getElementById('webcam-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        async function initVision() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            document.getElementById('loading-text').style.display = 'none';
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener('loadeddata', predictWebcam);
                document.getElementById('webcam-container').style.display = 'block';
            });
        }

        let lastVideoTime = -1;
        function predictWebcam() {
            canvasElement.width = video.videoWidth; canvasElement.height = video.videoHeight;
            if (lastVideoTime !== video.currentTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                if (results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];
                    const drawingUtils = new DrawingUtils(canvasCtx);
                    drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, {color: "#00FF00", lineWidth: 2});
                    drawingUtils.drawLandmarks([landmarks[4], landmarks[8]], {color: "#FF0000", lineWidth: 3});
                    if (config.handControl) processSingleHand(landmarks);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processSingleHand(hand) {
            const palmX = hand[9].x; 
            targetRotationY = (palmX - 0.5) * 4.0;
            const thumb = hand[4];
            const index = hand[8];
            const distance = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
            const minOpen = 0.02; const maxOpen = 0.25; 
            let normalizedDist = (distance - minOpen) / (maxOpen - minOpen);
            normalizedDist = Math.max(0, Math.min(1, normalizedDist));
            targetScale = 0.5 + normalizedDist * 2.0; 
        }

        // --- GUI 设置 (更新处) ---
        const gui = new GUI({ container: document.getElementById('ui-container') });
        const visualFolder = gui.addFolder('视觉设置'); // 创建文件夹分类
        
        // 颜色选择器
        visualFolder.addColor(config, 'particleColor')
            .name('粒子颜色')
            .onChange(c => material.uniforms.uColor.value.set(c));
            
        // 粒子大小调整 (1.0 到 20.0)
        visualFolder.add(config, 'particleSize', 1.0, 20.0)
            .name('粒子大小')
            .onChange(v => {
                // 更新 Shader 中的 uSize，同时考虑屏幕像素比，保证清晰度
                material.uniforms.uSize.value = v * renderer.getPixelRatio();
            });

        const controlFolder = gui.addFolder('交互设置');
        controlFolder.add(config, 'handControl').name('启用摄像头控制');
        
        // 默认展开视觉设置
        visualFolder.open();
        controlFolder.open();

        // --- 循环 ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getElapsedTime();
            material.uniforms.uTime.value = dt;
            material.uniforms.uDispersion.value += (targetDispersion - material.uniforms.uDispersion.value) * 0.1;
            particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.1;
            const currentScale = particles.scale.x;
            particles.scale.setScalar(currentScale + (targetScale - currentScale) * 0.1);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // 窗口变化时重新计算粒子大小
            material.uniforms.uSize.value = config.particleSize * renderer.getPixelRatio();
        });
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            !document.fullscreenElement ? document.body.requestFullscreen() : document.exitFullscreen();
        });

        initVision();
        animate();

    </script>
</body>
</html>
