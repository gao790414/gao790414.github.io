<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 粒子爱心 - 允允</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; }
        
        /* UI 覆盖层样式 */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        /* 提示文字 */
        .instruction {
            position: absolute;
            bottom: 80px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: pulse 2s infinite;
        }

        /* 全屏按钮 */
        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            z-index: 10;
            font-size: 12px;
        }
        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }
    </style>
</head>
<body>

    <div id="ui-container"></div>
    <div class="instruction">上下滑动扩散 · 左右滑动旋转</div>
    <button id="fullscreen-btn">⛶ 全屏模式</button>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 配置参数 ---
        const config = {
            particleColor: '#ff69b4', // 初始粉色
            particleSize: 4.0,
            dispersion: 0.0, // 扩散程度 0-1
            rotationSpeed: 0.0,
            textScale: 0.15,
            heartScale: 15
        };

        // --- 场景初始化 ---
        const scene = new THREE.Scene();
        // 添加一点雾化效果，增加深度感
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 核心逻辑：生成粒子 ---

        // 1. 生成文字粒子数据 "允允"
        function getTextCoordinates(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 500; // 画布大小
            canvas.width = size;
            canvas.height = size;
            
            // 绘制文字
            ctx.font = 'bold 200px "Microsoft YaHei", sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size / 2, size / 2);

            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            const points = [];

            // 扫描像素
            for (let y = 0; y < size; y += 4) { // 步长决定密度
                for (let x = 0; x < size; x += 4) {
                    const alpha = data[(y * size + x) * 4 + 3];
                    if (alpha > 128) {
                        // 将 2D 像素坐标转换为 3D 坐标，并居中
                        points.push({
                            x: (x - size / 2) * config.textScale,
                            y: -(y - size / 2) * config.textScale, // Canvas Y轴相反
                            z: 0
                        });
                    }
                }
            }
            return points;
        }

        // 2. 生成爱心轮廓粒子数据
        function getHeartCoordinates(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                // 经典的爱心参数方程
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                
                // 稍微添加一点厚度
                const z = (Math.random() - 0.5) * 2; 

                points.push({
                    x: x * 0.5, // 缩放以匹配文字大小
                    y: y * 0.5,
                    z: z
                });
            }
            return points;
        }

        // 3. 组合并创建几何体
        const textPoints = getTextCoordinates("允允");
        const heartPoints = getHeartCoordinates(1500); // 1500个爱心轮廓点
        
        // 合并所有点
        const allPoints = [...textPoints, ...heartPoints];
        const particleCount = allPoints.length;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const randoms = new Float32Array(particleCount * 3); // 用于扩散方向的随机值

        for (let i = 0; i < particleCount; i++) {
            const p = allPoints[i];
            
            // 初始位置 (Target Position)
            positions[i * 3] = p.x;
            positions[i * 3 + 1] = p.y;
            positions[i * 3 + 2] = p.z;

            // 随机扩散方向 (Explosion Direction)
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 2 - 1);
            const r = 20 + Math.random() * 20; // 扩散半径

            randoms[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            randoms[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            randoms[i * 3 + 2] = r * Math.cos(phi);
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

        // --- Shader Material (关键：高性能动画) ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(config.particleColor) },
                uDispersion: { value: 0 }, // 由手势控制
                uSize: { value: config.particleSize * renderer.getPixelRatio() }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uDispersion;
                uniform float uSize;
                
                attribute vec3 aRandom;
                
                varying float vAlpha;

                // 简单的噪声函数
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    // 核心逻辑：位置 = 原始位置 + (随机向量 * 扩散系数)
                    // 使用 sin(uTime) 增加一点悬浮的呼吸感
                    vec3 stablePos = position + vec3(0.0, sin(uTime * 2.0 + position.x) * 0.2, 0.0);
                    
                    vec3 finalPos = mix(stablePos, stablePos + aRandom, uDispersion);

                    // 扩散时粒子变大一点，增加冲击力
                    gl_PointSize = uSize * (1.0 + uDispersion * 0.5);
                    
                    // 透视除法，让远处的粒子变小
                    gl_PointSize *= (20.0 / - (modelViewMatrix * vec4(finalPos, 1.0)).z);

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
                    
                    // 扩散越远，透明度越低
                    vAlpha = 1.0 - uDispersion * 0.8;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vAlpha;

                void main() {
                    // 圆形粒子绘制
                    vec2 uv = gl_PointCoord.xy - 0.5;
                    float r = length(uv);
                    if (r > 0.5) discard;

                    // 边缘柔化
                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 1.5);

                    gl_FragColor = vec4(uColor, vAlpha * glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- UI 面板 ---
        const gui = new GUI({ container: document.getElementById('ui-container') });
        gui.addColor(config, 'particleColor').name('粒子颜色').onChange(c => {
            material.uniforms.uColor.value.set(c);
        });
        gui.add(config, 'particleSize', 1, 10).name('粒子大小').onChange(v => {
            material.uniforms.uSize.value = v * renderer.getPixelRatio();
        });
        
        // 我们把扩散值留给手势控制，但在 UI 里显示用于调试
        const dispersionCtrl = gui.add(config, 'dispersion', 0, 1).name('扩散程度').listen();


        // --- 交互系统 ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotationY = 0;
        let targetDispersion = 0;

        // 统一处理触摸和鼠标事件
        const onStart = (x, y) => {
            isDragging = true;
            previousMousePosition = { x, y };
        };

        const onMove = (x, y) => {
            if (!isDragging) return;

            const deltaX = x - previousMousePosition.x;
            const deltaY = y - previousMousePosition.y;

            // 左右滑动 -> 旋转
            targetRotationY += deltaX * 0.005;

            // 上下滑动 -> 扩散 (向下 y 增大 -> 扩散增加)
            // 归一化移动距离到 0-1 之间
            const sensitivity = 0.005;
            targetDispersion += deltaY * sensitivity;
            
            // 限制范围
            targetDispersion = Math.max(0, Math.min(1, targetDispersion));
            config.dispersion = targetDispersion;

            previousMousePosition = { x, y };
        };

        const onEnd = () => {
            isDragging = false;
        };

        // Mouse Events
        window.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', onEnd);

        // Touch Events
        window.addEventListener('touchstart', e => onStart(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        window.addEventListener('touchmove', e => {
            e.preventDefault(); // 防止页面滚动
            onMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        window.addEventListener('touchend', onEnd);


        // --- 全屏功能 ---
        const btn = document.getElementById('fullscreen-btn');
        btn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.body.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message}`);
                });
                btn.innerText = "⛶ 退出全屏";
            } else {
                document.exitFullscreen();
                btn.innerText = "⛶ 全屏模式";
            }
        });

        // --- 动画循环 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // 更新 Shader Uniforms
            material.uniforms.uTime.value = elapsedTime;
            
            // 缓动动画 (Lerp) 让交互更平滑
            // 扩散值的平滑过渡
            const currentDispersion = material.uniforms.uDispersion.value;
            material.uniforms.uDispersion.value += (targetDispersion - currentDispersion) * 0.1;
            
            // 旋转的平滑过渡
            particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.05;

            // 自动微旋转（如果没有在交互）
            if (!isDragging && targetDispersion < 0.1) {
                particles.rotation.y += 0.001;
                targetRotationY = particles.rotation.y; // 同步状态
            }

            renderer.render(scene, camera);
        }

        // --- 窗口自适应 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uSize.value = config.particleSize * renderer.getPixelRatio();
        });

        animate();

    </script>
</body>
</html>
